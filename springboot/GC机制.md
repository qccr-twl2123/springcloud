### java GC 机制
```text
三种策略: 分代回收,增量回收,并行回收
三种方案: 标记清除,复制收集,引用计数

垃圾回收讲得很简单清楚。三种基本形式：标记式，拷贝式，计数器式；三种高级形式：
分代回收；增量回收；并行回收；高级形式的底层都是运用三种基本形式。

```

![输入图片说明](https://github.com/qccr-twl2123/springcloud/blob/master/images/编程语言的过去现在和未来.png "在这里输入图片标题")


* 标记清除
```text
标记清除（Mark and Sweep）是最早开发出的GC算法（1960年）。它的原理非常简单，首先从根开始将可能被引用的对象用递归的方式进行标记，
然后将没有标记到的对象作为垃圾进行回收
```
![输入图片说明](https://github.com/qccr-twl2123/springcloud/blob/master/images/标记.png "在这里输入图片标题")
```text
图1显示了标记清除算法的大致原理。图1中的（1）部分显示了随着程序的运行而分配出一些对象的状态，一个对象可以对其他的对象进行引用。图中（2）部分中，GC开始执行，从根开始对可能被引用的对象打上“标记”。大多数情况下，这种标记是通过对象内部的标志（Flag）来实现的。于是，被标记的对象我们把它们涂黑。图中（3）部分中，被标记的对象所能够引用的对象也被打上标记。重复这一步骤的话，就可以将从根开始可能被间接引用到的对象全部打上标记。到此为止的操作，称为标记阶段（Mark phase）。

标记阶段完成时，被标记的对象就被视为“存活”对象。图1中的（4）部分中，将全部对象按顺序扫描一遍，将没有被标记的对象进行回收。这一操作被称为清除阶段（Sweep phase）。

在扫描的同时，还需要将存活对象的标记清除掉，以便为下一次GC操作做好准备。标记清除算法的处理时间，是和存活对象数与对象总数的总和相关的。
作为标记清除的变形，还有一种叫做标记压缩（Mark and Compact）的算法，它不是将被标记的对象清除，而是将它们不断压缩。

```

* 复制收集
```text

```
* 引用计数
````text

````

